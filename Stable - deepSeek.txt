#include <Wire.h>
#include <RTClib.h>
#include <WiFi.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
#include <Preferences.h>
#include <ESP32Encoder.h>

// Версия ПО
#define FIRMWARE_VERSION "1.0" // Major.Minor

// Конфигурация пинов
#define LED_PIN 48
#define I2C_SDA 4
#define I2C_SCL 5
#define SQW_PIN 6  // Пин для прерываний от DS3231

// Пины энкодера (подставьте свои номера!)
#define ENC_A 15  // Пин "A" энкодера
#define ENC_B 16  // Пин "B" энкодера
#define ENC_BTN 17  // Пин кнопки (опционально)

ESP32Encoder encoder;

// Константы
#define TIME_BUF_SIZE 64
#define TZ_BUF_SIZE 60
#define NTP_SERVER_SIZE 32

// Настройки таймера (для 240 МHz)
#define TIMER_DIVIDER 80      // 240MHz/80 = 3MHz
#define TIMER_INTERVAL 3000000 // 3MHz = 3 000 000 тиков/сек (1 сек)

/


// Сама структура Config
struct Config {
    char wifi_ssid[32];
    char wifi_pass[32];
    char ntp_server[NTP_SERVER_SIZE];
    int8_t timezone_offset;
    bool dst_enabled;
    uint8_t dst_preset_index;
    char dst_rule[64];
    char serial_number[12];

    struct AlarmSettings {
        uint8_t hour;
        uint8_t minute;
        bool enabled;
    };
    
    AlarmSettings alarm1;
    AlarmSettings alarm2;
};

// Глобальные объекты
enum TimeSource { INTERNAL_RTC, EXTERNAL_DS3231 };
TimeSource currentTimeSource = INTERNAL_RTC;
RTC_DS3231 *rtc = nullptr;
WiFiUDP ntpUDP;
NTPClient *timeClient;
Preferences preferences;
Config config;

// Таймер и прерывания
hw_timer_t *timer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;
volatile bool timeUpdated = false;



// Прототипы функций
void initConfiguration();
void setDefaultConfig();
void saveConfig();
void initTimeSource();
bool syncTime();
void setTimeZone(int8_t offset, bool dst_enabled, uint8_t preset_index);
bool setDstPreset(uint8_t index);
bool printTime();
void printHelp();
void printSystemInfo();
void handleSerialCommands();
void blinkError(int count);
bool CheckButton(bool *pressed, bool *released);
bool setManualTime(const String &timeStr);
bool setManualDate(const String &dateStr);
bool setAlarm(uint8_t alarmNum, const String &timeStr);
void checkAlarms();
void IRAM_ATTR onTimeInterrupt();
void setupInterrupts();
time_t getCurrentTime();
void printSettings();
bool setDstPresetByName(const String& name);
void printDstPresets();
bool isDigit(char c);

// --- Глобальные переменные ---
bool printEnabled = false;

// Глобальные переменные для обработки кнопки
static uint8_t buttonBounceCount = 0;
static bool buttonStableState = HIGH;
static uint32_t buttonPressStartTime = 0;
static bool longPressHandled = false;
static bool veryLongPressHandled = false;

// Возвращаемые статусы
#define BUTTON_NONE     0
#define BUTTON_PRESSED  1
#define BUTTON_LONG     2
#define BUTTON_VERY_LONG 3
/ Вне структуры (глобально, но в пространстве имён config)

const char* DST_PRESETS[] = {
    // Европа
    "EU", "CET-1CEST-2,M3.5.0/02:00:00,M10.5.0/03:00:00", "Европа (кроме Украины, Польши, UK)",
    "UK", "GMT0BST,M3.5.0/01:00:00,M10.5.0/02:00:00",     "Великобритания",
    "UA", "EET-2EEST-3,M3.5.0/03:00:00,M10.5.0/04:00:00", "Украина",
    "PL", "CET-1CEST-2,M3.5.0/02:00:00,M10.5.0/03:00:00", "Польша",

    // Америка
    "US", "EST5EDT,M3.2.0/02:00:00,M11.1.0/02:00:00",     "США/Канада",
    "MX", "CST6CDT,M4.1.0/02:00:00,M10.5.0/02:00:00",     "Мексика",
    "BR", "BRT3BRST,M11.1.0/00:00:00,M2.3.0/00:00:00",    "Бразилия (часть регионов)",

    // Ближний Восток
    "IL", "IST-2IDT-3,M3.4.4/02:00:00,M10.5.0/02:00:00",  "Израиль",
    "LB", "EET-2EEST-3,M3.5.0/00:00:00,M10.5.0/00:00:00", "Ливан",

    // Океания
    "AU", "AEST-10AEDT-11,M10.1.0/02:00:00,M4.1.0/03:00:00", "Австралия (NSW/VIC/ACT/TAS)",
    "NZ", "NZST-12NZDT-13,M9.5.0/02:00:00,M4.1.0/03:00:00",  "Новая Зеландия",

    // Без DST
    "NONE", "UTC0", "Без DST (чистый UTC)",
    nullptr
};

void setup() {
  // Настройка пинов Энкодера
  pinMode(ENC_A, INPUT_PULLUP);  // Подтяжка к питанию
  pinMode(ENC_B, INPUT_PULLUP);
  pinMode(ENC_BTN, INPUT_PULLUP);

  // Инициализация энкодера
  encoder.attachSingleEdge(ENC_A, ENC_B);  // Указываем пины A и B
  encoder.setFilter(5000);  // Дополнительный программный фильтр
  encoder.setCount(0);  // Сброс счётчика

  Serial.begin(115200);
  delay(500);
  
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, HIGH);

  initConfiguration();
  timeClient = new NTPClient(ntpUDP, config.ntp_server, 0);
  initTimeSource();
  syncTime();
  setTimeZone(config.timezone_offset, config.dst_enabled, config.dst_preset_index);
  
  setupInterrupts();
  printSystemInfo();
  printHelp();
  printEnabled=true;
}

void loop() {
  static time_t lastDisplayTime = 0;

  uint32_t now = millis();

  // Переменные для энкодера
  static int32_t lastPos = 0;         // Последнее известное положение
  int32_t currentPos = encoder.getCount();

  bool pressed = false, released = false;

//Проверка нажатия на кнопку  
  uint8_t buttonEvent = CheckButton();

  switch (buttonEvent) {
    case BUTTON_PRESSED:
      Serial.println("Короткое нажатие");
      break;
    case BUTTON_LONG:
      Serial.println("Длинное нажатие");
      break;
    case BUTTON_VERY_LONG:
      Serial.println("Очень длинное нажатие");
      break;
  }

//Энкодер
 // Вывод позиции энкодера при изменении
  if (currentPos != lastPos) {
    Serial.printf("%d\n", currentPos);
    lastPos = currentPos;
  }



//Обновление времени
  if(timeUpdated) {
    portENTER_CRITICAL(&timerMux);
    timeUpdated = false;
    portEXIT_CRITICAL(&timerMux);
    
    time_t currentTime = getCurrentTime();

    if(currentTime != lastDisplayTime) {
    lastDisplayTime = currentTime;
    updateDisplay(currentTime);
    
    // Получаем текущие секунды
    struct tm *timeinfo = localtime(&currentTime);
    uint8_t seconds = timeinfo->tm_sec;
    
    // Проверяем кратность 10 секундам (0, 10, 20...50)
    if((seconds % 20 == 0)&&(printEnabled)) {
        printTime(); // Выводим время только каждые 20 секунд
    } 
  }
  }

  if(Serial.available()) {
    handleSerialCommands();
  }

//Проверка будильников
checkAlarms();

  delay(10);

}


void IRAM_ATTR onTimeInterrupt() {
  portENTER_CRITICAL_ISR(&timerMux);
  timeUpdated = true;
  digitalWrite(LED_PIN, HIGH); //Включаем светодиод - выключается он при вызове ф-и вывода на дисплей
  portEXIT_CRITICAL_ISR(&timerMux);
}

void setupInterrupts() {
  if(currentTimeSource == EXTERNAL_DS3231 && rtc) {
    rtc->writeSqwPinMode(DS3231_SquareWave1Hz);
    pinMode(SQW_PIN, INPUT_PULLUP);
    attachInterrupt(digitalPinToInterrupt(SQW_PIN), onTimeInterrupt, FALLING);
    Serial.println("Используются аппаратные прерывания SQW");
  } else {
    // Настройка таймера для ESP32-S3 (240 MHz)
    timer = timerBegin(1000000); // 1MHz (1 000 000 тиков в секунду)
    timerAttachInterrupt(timer, onTimeInterrupt);
    timerAlarm(timer, 1000000, true, 0); // 1 секунда, автоповтор
    Serial.println("Используется программный таймер");
  }
}
time_t getCurrentTime() {
  if(currentTimeSource == EXTERNAL_DS3231 && rtc) {
    return rtc->now().unixtime();
  } else {
    struct tm timeinfo;
    if(getLocalTime(&timeinfo)) {
      return mktime(&timeinfo);
    }
    return 0;
  }
}
time_t getRTCTime() {
  if(currentTimeSource == EXTERNAL_DS3231 && rtc) {
    return rtc->now().unixtime();
  } else {
    struct tm timeinfo;
    getLocalTime(&timeinfo);
    return mktime(&timeinfo);
  }
}
void updateDisplay(time_t now) {
  digitalWrite(LED_PIN, LOW); //Выключаем светодиод - он включился при поступлении прерывания от таймера
}
void handleSerialCommands() {
  if(!Serial.available()) return;
  
  String command = Serial.readStringUntil('\n');
  command.trim();
  
  if(command.equals("help")) {
    printHelp();
  }
  else if(command.equals("time")) {
    printTime();
  }
  else if(command.equals("sync")) {
    syncTime();
  }
  else if (command.startsWith("setup")) {
  printEnabled=false;
  printSettings();
  }
  else if(command.startsWith("set ssid ")) {
    String ssid = command.substring(9);
    if(ssid.length() > 0 && ssid.length() < sizeof(config.wifi_ssid)) {
      ssid.toCharArray(config.wifi_ssid, sizeof(config.wifi_ssid));
      saveConfig();
      Serial.println("SSID обновлен");
    } else {
      Serial.println("Ошибка: недопустимая длина SSID");
    }
  }
  else if(command.startsWith("set pass ")) {
    String pass = command.substring(9);
    if(pass.length() > 0 && pass.length() < sizeof(config.wifi_pass)) {
      pass.toCharArray(config.wifi_pass, sizeof(config.wifi_pass));
      saveConfig();
      Serial.println("Пароль обновлен");
    } else {
      Serial.println("Ошибка: недопустимая длина пароля");
    }
  }
  else if(command.startsWith("set ntp ")) {
    String ntp = command.substring(8);
    if(ntp.length() > 0 && ntp.length() < sizeof(config.ntp_server)) {
      ntp.toCharArray(config.ntp_server, sizeof(config.ntp_server));
      saveConfig();
      delete timeClient;
      timeClient = new NTPClient(ntpUDP, config.ntp_server, 0);
      Serial.println("NTP сервер обновлен");
    } else {
      Serial.println("Ошибка: недопустимая длина адреса NTP сервера");
    }
  }
  else if(command.startsWith("set tz ")) {
    int8_t tz = command.substring(7).toInt();
    if(tz >= -12 && tz <= 14) {
        config.timezone_offset = tz;
        saveConfig();
        setTimeZone(config.timezone_offset, config.dst_enabled, config.dst_preset_index);
        Serial.println("Часовой пояс обновлен");
    } else {
        Serial.println("Ошибка: недопустимое значение часового пояса (-12..14)");
    }
  } 
  else if (command.startsWith("set dst ")) {
    String arg = command.substring(8);
    bool success = false;
    
    // Проверяем, является ли аргумент числом
    if (isDigit(arg.charAt(0))) {
        uint8_t idx = arg.toInt();
        success = setDstPreset(idx);  // Старый метод по индексу
    } else {
        success = setDstPresetByName(arg);  // Новый метод по коду страны
    }

    if (success) {
        Serial.println("Применяем новые настройки времени...");
        syncTime();
        Serial.printf("Текущий DST: %s (%s)\n", 
                     DST_PRESETS[config.dst_preset_index * 3], 
                     DST_PRESETS[config.dst_preset_index * 3 + 2]);
    } else {
        Serial.println("Ошибка: укажите номер (0-4) или код страны (EU, US, UA и др.)");
        Serial.println("Используйте 'show dst' для списка доступных пресетов");
    }
  }
  else if (command.equals("show dst")) {
    Serial.println("Доступные DST пресеты:");
    for (int i = 0; DST_PRESETS[i] != nullptr; i += 2) {
        Serial.printf("%d: %s -> %s\n", i/2, DST_PRESETS[i], DST_PRESETS[i+1]);
    }
  }
  else if(command.startsWith("set sn ")) {
    String sn = command.substring(7);
    if(sn.length() == 11) {
      sn.toCharArray(config.serial_number, sizeof(config.serial_number));
      saveConfig();
      Serial.println("Серийный номер обновлен");
    } else {
      Serial.println("Ошибка: серийный номер должен быть 11 символов");
    }
  }
  else if(command.equals("show config")) {
    Serial.println("\n=== Текущие настройки ===");
    Serial.printf("SSID: %s\n", config.wifi_ssid);
    Serial.printf("Пароль: %s\n", config.wifi_pass);
    Serial.printf("NTP сервер: %s\n", config.ntp_server);
    Serial.printf("Часовой пояс: UTC%+d\n", config.timezone_offset);
    Serial.printf("Серийный номер: %s\n", config.serial_number);
    Serial.printf("Будильник 1: %s %02d:%02d\n", 
        config.alarm1.enabled ? "Вкл" : "Выкл",
        config.alarm1.hour, config.alarm1.minute);
    Serial.printf("Будильник 2: %s %02d:%02d\n", 
        config.alarm2.enabled ? "Вкл" : "Выкл",
        config.alarm2.hour, config.alarm2.minute);  
  }
  else if(command.equals("reset config")) {
    preferences.begin("config", false);
    preferences.clear();
    preferences.end();
    setDefaultConfig();
    delete timeClient;
    timeClient = new NTPClient(ntpUDP, config.ntp_server, 0);
    Serial.println("Конфигурация сброшена к значениям по умолчанию");
  }
  else if (command.startsWith("set time ")) {
  String timeStr = command.substring(9);
  setManualTime(timeStr);
  }
  else if (command.startsWith("set date ")) {
  String dateStr = command.substring(9);
  setManualDate(dateStr);
  }
  else if (command.startsWith("set al 1 ")) {
    String timeStr = command.substring(8);
    setAlarm(1, timeStr);
  } 
  else if (command.startsWith("set al 2 ")) {
    String timeStr = command.substring(8);
    setAlarm(2, timeStr);
  } 
  else if (command.startsWith("out")) {
  printHelp(); 
  printEnabled=true;
  }
  else {
    Serial.println("Неизвестная команда. Введите 'help' для списка команд");
  }
}
void initConfiguration() {
  preferences.begin("config", false);
  
  // Проверяем, есть ли сохраненная конфигурация
  if(preferences.getBytesLength("data") != sizeof(config)) {
    // Устанавливаем новые значения по умолчанию
    setDefaultConfig();
    Serial.println("Установлены настройки по умолчанию");
  } else {
    // Загружаем сохраненную конфигурацию
    preferences.getBytes("data", &config, sizeof(config));
    Serial.println("Конфигурация загружена из памяти");
  }
  
  preferences.end();
}
void setDefaultConfig() {
  memset(&config, 0, sizeof(config));
  strlcpy(config.wifi_ssid, "Hogwarts-2.4", sizeof(config.wifi_ssid));
  strlcpy(config.wifi_pass, "Alohomora!", sizeof(config.wifi_pass));
  strlcpy(config.ntp_server, "pool.ntp.org", sizeof(config.ntp_server));
  config.dst_enabled = false;
  config.dst_preset_index = 0; //Europe
  strlcpy(config.dst_rule, "UTC+0", sizeof(config.dst_rule));
  strlcpy(config.serial_number, "NC111115861", sizeof(config.serial_number));
  config.alarm1 = {0, 0, false};
  config.alarm2 = {0, 0, false};
  saveConfig();
}
void saveConfig() {
  preferences.begin("config", false);
  preferences.putBytes("data", &config, sizeof(config));
  preferences.end();
}
void initTimeSource() {
  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(100000);
  
  // Проверка наличия DS3231
  Wire.beginTransmission(0x68);
  if(Wire.endTransmission() == 0) {
    rtc = new (std::nothrow) RTC_DS3231(); // Безопасное выделение памяти
    if(rtc && rtc->begin()) {
      currentTimeSource = EXTERNAL_DS3231;
      Serial.println("Используется внешний RTC (DS3231)");
      return;
    }
    if(rtc) delete rtc;
  }
  
  currentTimeSource = INTERNAL_RTC;
  Serial.println("Используется внутренний RTC");
}
bool syncTime() {
  digitalWrite(LED_PIN, HIGH); // Индикация начала синхронизации
  Serial.println("[NTP] Попытка синхронизации...");

  // Подключаемся к WiFi
  WiFi.mode(WIFI_STA);
  if (WiFi.begin(config.wifi_ssid, config.wifi_pass) != WL_CONNECTED) {
    for (int i = 0; i < 10 && WiFi.status() != WL_CONNECTED; i++) {
      delay(500);
      Serial.print(".");
    }
  }

  bool success = false;
  if (WiFi.status() == WL_CONNECTED) {
    timeClient->begin();
    timeClient->setTimeOffset(0); // Явно запрашиваем UTC

    if (timeClient->forceUpdate()) {
      time_t utcTime = timeClient->getEpochTime();
      
      setTimeZone(config.timezone_offset, config.dst_enabled, config.dst_preset_index);
      time_t localTime = utcTime + config.timezone_offset * 3600;
        if (config.dst_enabled) {
        localTime = mktime(localtime(&localTime)); // Автокоррекция DST
        }

      // Отладочный вывод (UTC + локальное время)
      struct tm *tm_utc = gmtime(&utcTime);
      struct tm *tm_local = localtime(&localTime);
      Serial.printf("[NTP] Получено UTC: %02d:%02d:%02d\n", 
                   tm_utc->tm_hour, tm_utc->tm_min, tm_utc->tm_sec);
      Serial.printf("[NTP] Локальное время: %02d:%02d:%02d (TZ=%+d, DST=%s)\n",
                   tm_local->tm_hour, tm_local->tm_min, tm_local->tm_sec,
                   config.timezone_offset, config.dst_enabled ? "ON" : "OFF");

      // Записываем время встроенного RTC
      struct timeval tv = { localTime, 0 };
      settimeofday(&tv, NULL);
      Serial.println("[RTC] Время записано во внутренний RTC");

      // Записываем в DS3231 (если подключён)
      if (currentTimeSource == EXTERNAL_DS3231 && rtc) {
        rtc->adjust(DateTime(localTime));
        Serial.println("[DS3231] Время записано в аппаратные часы");
      }

      success = true;
      digitalWrite(LED_PIN, LOW); // Успешное завершение
    }
    timeClient->end();
  }

  WiFi.disconnect(true);
  WiFi.mode(WIFI_OFF);

  if (!success) {
    blinkError(11); // Индикация ошибки
    Serial.println("[ERROR] Не удалось синхронизировать время!");
  }

  return success;
}
bool printTime() {
  char buf[TIME_BUF_SIZE]; // Объявляем буфер для строки времени
  bool success = false;    // Флаг успешного получения времени
  
  // 1. Пробуем получить время из DS3231 (если подключён)
  if (currentTimeSource == EXTERNAL_DS3231 && rtc) {
    DateTime now = rtc->now();
    if (snprintf(buf, sizeof(buf), "%02d:%02d:%02d %02d.%02d.%04d (DS3231)",
                now.hour(), now.minute(), now.second(),
                now.day(), now.month(), now.year()) > 0) {
      success = true;
    }
  }

  // 2. Если DS3231 не сработал, берём время из внутреннего RTC
  if (!success) {
    struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
      if (strftime(buf, sizeof(buf), "%H:%M:%S %d.%m.%Y (Internal RTC)", &timeinfo) > 0) {
        success = true;
      }
    } else {
      // 3. Если getLocalTime() не сработал, берём "сырое" время (с момента запуска)
      time_t rawTime;
      time(&rawTime);
      struct tm *timeinfo = localtime(&rawTime);
      strftime(buf, sizeof(buf), "%H:%M:%S %d.%m.%Y (Power-On Time)", timeinfo);
      success = true;
    }
  }
  
  Serial.print("Текущее время: ");
  Serial.println(buf);
  return success;
}
void setTimeZone(int8_t offset, bool dst_enabled, uint8_t preset_index) {
    char tz[TZ_BUF_SIZE];
    
    if (!dst_enabled) {
        snprintf(tz, sizeof(tz), "UTC%+d", offset);
    }
    else {
        if (preset_index * 2 + 1 < sizeof(DST_PRESETS)/sizeof(DST_PRESETS[0]) - 1) {
            strncpy(tz, DST_PRESETS[preset_index * 2 + 1], sizeof(tz));
        } else {
            strncpy(tz, "UTC0", sizeof(tz));
        }
    }

    setenv("TZ", tz, 1);
    tzset();
    Serial.printf("[TZ] Установлен пояс: %s\n", tz);
}
bool setDstPresetByName(const String& name) {
    for (int i = 0; DST_PRESETS[i] != nullptr; i += 3) {
        if (name.equalsIgnoreCase(DST_PRESETS[i])) {
            config.dst_preset_index = i/3;
            strncpy(config.dst_rule, DST_PRESETS[i+1], sizeof(config.dst_rule));
            saveConfig();
            Serial.printf("Установлен DST: %s (%s)\n", DST_PRESETS[i], DST_PRESETS[i+2]);
            return true;
        }
    }
    Serial.println("Ошибка: пресет не найден. Доступные варианты:");
    printDstPresets();
    return false;
}
bool setDstPreset(uint8_t index) {
    // Проверяем границы массива (учитываем, что теперь каждый пресет занимает 3 элемента)
    int max_presets = (sizeof(DST_PRESETS)/sizeof(DST_PRESETS[0])) / 3;
    
    if (index >= max_presets) {
        Serial.printf("Ошибка: допустимые значения 0-%d\n", max_presets-1);
        return false;
    }
    
    config.dst_preset_index = index;
    strlcpy(config.dst_rule, DST_PRESETS[index * 3 + 1], sizeof(config.dst_rule));
    saveConfig();
    Serial.printf("Установлен DST пресет: %s (%s)\n", 
                 DST_PRESETS[index * 3], 
                 DST_PRESETS[index * 3 + 2]);
    return true;
}
// Установка времени (часы:минуты:секунды)
bool setManualTime(const String &timeStr) {
  int hours, minutes, seconds;
  if (sscanf(timeStr.c_str(), "%d:%d:%d", &hours, &minutes, &seconds) != 3) {
    Serial.println("Ошибка формата времени. Используйте HH:MM:SS");
    return false;
  }

  if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59 || seconds < 0 || seconds > 59) {
    Serial.println("Ошибка: некорректное время (допустимо 00:00:00 - 23:59:59)");
    return false;
  }

  // Получаем текущее время из системы
  struct tm timeinfo;
  time_t now;
  time(&now);
  localtime_r(&now, &timeinfo);

  // Если дата не была установлена (1970 год), используем дату по умолчанию
  if (timeinfo.tm_year < 101) { // год менее 2001
    timeinfo.tm_year = 123;    // 2023 год (123 = 2023-1900)
    timeinfo.tm_mon = 0;       // январь
    timeinfo.tm_mday = 1;      // 1 число
    Serial.println("Установлена дата по умолчанию: 01.01.2023");
  }

  // Устанавливаем новое время (дата остаётся прежней)
  timeinfo.tm_hour = hours;
  timeinfo.tm_min = minutes;
  timeinfo.tm_sec = seconds;
  time_t newTime = mktime(&timeinfo);

  // Применяем изменения
  struct timeval tv = { newTime, 0 };
  settimeofday(&tv, NULL);

  // Обновляем аппаратные часы (если подключены)
  if (currentTimeSource == EXTERNAL_DS3231 && rtc) {
    rtc->adjust(DateTime(newTime));
  }

  // Сбрасываем счётчик прерываний
  portENTER_CRITICAL(&timerMux);
  portEXIT_CRITICAL(&timerMux);

  Serial.println("Время успешно обновлено");
  return true;
}
// Установка даты (день.месяц.год)
bool setManualDate(const String &dateStr) {
  int day, month, year;
  if (sscanf(dateStr.c_str(), "%d.%d.%d", &day, &month, &year) != 3) {
    Serial.println("Ошибка формата даты. Используйте DD.MM.YYYY");
    return false;
  }

  if (day < 1 || day > 31 || month < 1 || month > 12 || year < 2000 || year > 2100) {
    Serial.println("Ошибка: некорректная дата (допустимо 01.01.2000 - 31.12.2100)");
    return false;
  }

  // Получаем текущее время из системы
  struct tm timeinfo;
  time_t now;
  time(&now);
  localtime_r(&now, &timeinfo);

  // Проверяем валидность времени (новый способ)
  if (timeinfo.tm_hour < 0 || timeinfo.tm_hour > 23 ||
      timeinfo.tm_min < 0 || timeinfo.tm_min > 59 ||
      timeinfo.tm_sec < 0 || timeinfo.tm_sec > 59) {
    // Если время содержит недопустимые значения
    timeinfo.tm_hour = 0;
    timeinfo.tm_min = 0;
    timeinfo.tm_sec = 0;
    Serial.println("Обнаружены некорректные значения времени, установлено 00:00:00");
  }

  // Устанавливаем новую дату (время остаётся прежним)
  timeinfo.tm_mday = day;
  timeinfo.tm_mon = month - 1;  // январь = 0
  timeinfo.tm_year = year - 1900;
  time_t newTime = mktime(&timeinfo);

  // Применяем изменения
  struct timeval tv = { newTime, 0 };
  settimeofday(&tv, NULL);

  // Обновляем аппаратные часы (если подключены)
  if (currentTimeSource == EXTERNAL_DS3231 && rtc) {
    rtc->adjust(DateTime(newTime));
  }

  // Сбрасываем счётчик прерываний
  portENTER_CRITICAL(&timerMux);
  portEXIT_CRITICAL(&timerMux);

  Serial.println("Дата успешно обновлена");
  return true;
}

uint8_t CheckButton() {
  bool currentState = digitalRead(ENC_BTN);
  uint32_t currentTime = millis();
  uint8_t result = BUTTON_NONE;

  // Обработка антидребезга
  if (currentState != buttonStableState) {
    buttonBounceCount++;
    if (buttonBounceCount >= 3) {  // Стабильное состояние
      buttonStableState = currentState;
      buttonBounceCount = 0;

      if (buttonStableState == LOW) {  // Кнопка нажата
        buttonPressStartTime = currentTime;
        longPressHandled = false;
        veryLongPressHandled = false;
        result = BUTTON_PRESSED;
      }
    }
  } else {
    buttonBounceCount = 0;
  }

  // Проверка длинных нажатий (только если кнопка удерживается)
  if (buttonStableState == LOW) {
    uint32_t pressDuration = currentTime - buttonPressStartTime;

    if (!longPressHandled && pressDuration >= 1000) {  // 1 секунда
      longPressHandled = true;
      result = BUTTON_LONG;
    } 
    else if (!veryLongPressHandled && pressDuration >= 3000) {  // 5 секунд
      veryLongPressHandled = true;
      result = BUTTON_VERY_LONG;
    }
  }

  return result;
}

// Установка будильника (общая функция)
bool setAlarm(uint8_t alarmNum, const String &timeStr) {
    int hours, minutes;
    if (sscanf(timeStr.c_str(), "%d:%d", &hours, &minutes) != 2) {
        Serial.println("Ошибка формата. Используйте HH:MM");
        return false;
    }

    if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
        Serial.println("Ошибка: некорректное время (00:00 - 23:59)");
        return false;
    }

    if (alarmNum == 1) {
        config.alarm1.hour = hours;
        config.alarm1.minute = minutes;
        config.alarm1.enabled = true;
    } else if (alarmNum == 2) {
        config.alarm2.hour = hours;
        config.alarm2.minute = minutes;
        config.alarm2.enabled = true;
    } else {
        Serial.println("Ошибка: неверный номер будильника (1 или 2)");
        return false;
    }

    saveConfig();
    Serial.printf("Будильник %d установлен на %02d:%02d\n", alarmNum, hours, minutes);
    return true;
}

// Проверка срабатывания будильников
void checkAlarms() {
    static uint8_t lastCheckedHour = 255;  // Недопустимые начальные значения
    static uint8_t lastCheckedMinute = 255;
    
    time_t now = getCurrentTime();
    struct tm *timeinfo = localtime(&now);
    
    // Проверяем только при изменении часа или минуты
    if (timeinfo->tm_hour == lastCheckedHour && 
        timeinfo->tm_min == lastCheckedMinute) {
        return;
    }

    // Обновляем последние проверенные значения
    lastCheckedHour = timeinfo->tm_hour;
    lastCheckedMinute = timeinfo->tm_min;
    
    // Лямбда для проверки одного будильника
    auto checkAlarm = [timeinfo](const Config::AlarmSettings &alarm, uint8_t num) {
        if (alarm.enabled && 
            alarm.hour == timeinfo->tm_hour && 
            alarm.minute == timeinfo->tm_min) {
            Serial.printf("[ALARM %d] Сработал в %02d:%02d:%02d\n", 
                        num, 
                        timeinfo->tm_hour, 
                        timeinfo->tm_min, 
                        timeinfo->tm_sec);
            // Добавьте здесь звук/световую индикацию
        }
    };
    
    checkAlarm(config.alarm1, 1);
    checkAlarm(config.alarm2, 2);
}

void blinkError(int count) {
  pinMode(LED_PIN, OUTPUT);
  for(int i = 0; i < count; i++) {
    digitalWrite(LED_PIN, HIGH);
    delay(200);
    digitalWrite(LED_PIN, LOW);
    delay(200);
  }
}
bool isDigit(char c) {
    return c >= '0' && c <= '9';
}
void printDstPresets() {
    Serial.println("Доступные DST пресеты:");
    for (int i = 0; DST_PRESETS[i] != nullptr; i += 3) {
        // Форматируем правило для читаемости
        String rule = String(DST_PRESETS[i+1]);
        rule.replace(",", ", "); // Добавляем пробелы после запятых
        
        Serial.printf("%s: (%d) %s - %s\n",
            DST_PRESETS[i],      // Код страны
            i/3,                 // Номер пресета
            rule.c_str(),        // Форматированное правило
            DST_PRESETS[i+2]     // Описание
        );
    }
}

void printSystemInfo() {
  Serial.println("\n=== Системная информация ===");
  Serial.printf("Версия ПО: %s\n", FIRMWARE_VERSION);
  Serial.printf("IDF версия: %s\n", esp_get_idf_version());
  Serial.printf("CPU частота: %d MHz\n", ESP.getCpuFreqMHz());
  Serial.printf("Свободная память: %d байт\n", ESP.getFreeHeap());
  Serial.printf("Серийный номер: %s\n", config.serial_number);
  Serial.printf("WiFi SSID: %s\n", config.wifi_ssid);
  Serial.printf("NTP сервер: %s\n", config.ntp_server);
  Serial.printf("Часовой пояс: UTC%+d\n", config.timezone_offset);
  Serial.printf("Источник времени: %s\n", 
               currentTimeSource == EXTERNAL_DS3231 ? "DS3231" : "Внутренний RTC");
  Serial.println("==========================");
}

void printHelp() {
  Serial.println("\n=== Доступные команды ===");
  Serial.println("help - показать это сообщение");
  Serial.println("time - показать текущее время");
  Serial.println("sync - синхронизировать время");
  Serial.println("show config - показать текущие настройки");
  Serial.println("setup - отобразить команды доступных настроек");
  Serial.println("reset config - сбросить настройки к значениям по умолчанию");
  Serial.println("==========================\n");
}

void printSettings() {
  Serial.println("\n=== Доступные настройки ===");
  Serial.println("\n-=ВНИМАНИЕ! До подачи команды ''out'' время в терминал не выдаётся=-\n");
  Serial.println("set time [HH:MM:SS] - установить время вручную");
  Serial.println("set date [DD.MM.YYYY] - установить дату вручную");
  Serial.println("set al 1 [HH:MM] - установить время будильника 1");
  Serial.println("set al 2 [HH:MM] - установить время будильника 2");
  Serial.println("set ssid [SSID] - изменить SSID WiFi");
  Serial.println("set pass [PASSWORD] - изменить пароль WiFi");
  Serial.println("set ntp [SERVER] - изменить NTP сервер");
  Serial.println("set tz [OFFSET] - изменить часовой пояс (-12..14)");
  Serial.println("set dst [0-4] - выбрать DST пресет");
  Serial.println("show dst - показать доступные DST пресеты");
  Serial.println("set sn [SERIAL] - изменить серийный номер (11 символов)");
  Serial.println("reset config - сбросить настройки к значениям по умолчанию");
  Serial.println("out - выход из меню настроек");
  Serial.println("==========================\n");  
}
